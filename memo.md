## osについて学ぶ

### 抽象化がどのように使われているか

### ハードウェアのリソースとは

### androidはosなのか
システムのスタックなので違う

### コンピュータの研究者にとっての一番の武器は
抽象化の概念
### 抽象化ではないものはどれか
抽象化とはインターフェースである
特定の機能について具体的なもの

### google earthを使っている時にアプリとpcの間で行われている抽象化は
抽象化とはソフトウェアとハードウェアの出会い
applicationがあり
コンパイルされ
様々なアーキテクチャに従い
データパスを通り命令制御を抜けトランジスタによって電子変換される

### まとめ
アプリとハードウェアの中間での役割を学んだ.
ハードウェアが実装を気にしないで良くなるようにする

## ハードウェアのリソース

### osの役割とは
アクセス権の制御

### 誰から制御をして守るのか

### コンピュータの内部システムの基本構造は

プロセッサ, メモリで構成されている

### osを学ぶ前に知っておく必要があるc言語の内容は

### プログラミング言語はどんなルールがあるのか
動詞と目的語でできている

### 目的語とは
他動詞の表す動作のこと

### どんなサイトか
全20章に渡るもの
c言語の基礎を学べる
15章がポインタなので詰まるかも

### c言語の構造とは
c言語のプログラムは関数の集まり

### 関数の構造は
型名 関数名(引数) {処理}

### c言語で使えない名前は
予約話と予約済み識別子

### 順番がない関数をどこから動かすことができるのか
mainとついた名前の関数から動作する

### ない場合はどうなるのか
プログラムが動作しない

### コンパイル方法は
cc ファイル名
./*.out => 実行

### 機械語とは
0と1だけで表現される2進数
2進数の4桁を16進数の1桁表現するようになった

### コンパイラの3段階の仕組み
1. プリプロセッサで前処理(空白消したりとかの調整)
2. コンパイラによる処理
3. リンカという統合ソフトで処理される
実行ファイルであるexeファイルができる

c言語とは関数の集合体である
型 関数(引数) {処理}
コンパイラ

int main(void) {
  return 0;
}

c言語が関数をコンパイルする際にルールとしてmainと名前がついたものを探す。mainと名前がついたものがなければ実行されない仕組みになっている。c言語は関数の集合体, よって順番の概念が存在しない。

### tokenとは
c言語の単語を分解した際の最小単位
returnを re と turnに分けると意味が変わる

### フリーフォーマットとは
自由書式なので, 書き方に関しては制限がない
### 自由の中にも存在するルールとは
1. トークン同士をくっつけてはいけない
2. 大文字と小文字は区別されている(別のtokenとして扱われる)
3. 終了tokenとなる";"が必要
4. 全角文字は認識できない

token
フリーフォーマット
する
インデント
コメント

### 説明書の読み取りとは
printf関数はc言語独自の関数ではないため実行できない
必要な機能を別途読み込ませて処理する必要がある
そのために"#include"が存在する

 ### 擬似命令 #includeとは
 プログラムではないコードのこと。機械語に翻訳される前に解釈されるもの

### 改行問題とは
### エスケープシーケンスとは
好きな位置で改行させる際に使うもの
意味を持った記号のこと。今回改行を行うために"\n"という特殊文字を使う

printf関数
#include <stdio.h>
エスケープシーケンス

文字の中のスペースは\tを使って表したほうが楽

## 文字列と数値

### 数値と数字の違いとは
数値は数を表現するもの。計算に使える
数字は見た目は数値と同じだが計算に使えない.文字と同じ扱いかも
### 文字列リテラルとは
プログラムの中に埋め込まれた""で囲まれた文字の定数


### 数値の表示方法
### 出力変換指定子とは
外部のデータを文字列に変換して表示したい時に変換方法を指定する記号。
数値を数字に変換するには"%d"を使う

### 文字列と数字とをどう組み合わせるか
"%d"指定子は他の文字列を組み合わせて使うことができる、
```c
printf("%d円\n%d円\n", 100, 500);
```
をというように複数出力変換子を使うと引数に取った数分に合わせる必要あり
### 数字を変数に割り当てる場合は型の指定は必要なのか?
必要
### 割り算を行った時に割り切れない場合の値はどうなるのか
切り捨てられる。切り上げられると逆計算を行った際に値が大きくなるため

### c言語における数値の種類とは
整数と実数
整数は自然数に0と負の数を追加したもの
実数は
数直線上で表せる数値
よって整数値に少数を付け加えたもの
先頭に0をつけない場合は10進数
先頭に0をつけた数は8進数
先頭に0xをつけたら16進数
c言語では実数のことを浮動小数点と呼ぶことがよくある
### 浮動小数点とは
数値の並びと小数点の位置で実数を表す方式

### 実数値を表す出力変換指定子とは
%fを使う変数を使った時も%fは実数を期待しているので小数点の値を期待しているため, 整数値を入れるとコンパイルエラーになる

文字列リテラル
"*"
"/"
浮動小数点
2
2.777

## 数値の記憶

### 変数とは
数値を保存しておくためのメモリ領域に名前をつけること
### メモリとは
横一列のとんでもない長さのロッカーのこと。とんでもない長さのロッカーなのでその場所に名前をつけて管理する
### 変数の宣言とは
変数に名前をつけること
`型名 変数名;`
変数の宣言は関数の先頭でしかできない.
しかし最新のc言語のバージョンでは可能

### データ型

### 型のキャストとは
強制的に型を変換する機能。計算結果などをdoubleからintに変換する際に指定できたりする
 (型)(計算)

### c言語で言語で整数と実数の計算をするとどうなるか
doubleになる

### 整数の桁揃えとは
出力する数字の桁を指定できること。%5dとかにすると5桁の数値のインデントを右端揃えにしてくれる

変数
代入
インクリメント

### 入力用の関数とは

### scanf関数とは
キーボードからの入力する用の関数
scanf("入力変換指定子", &変数名);
入力変換指定子の前後に文字などを入れるとそれも影響する

### 入力変換指定子とは
入力された数字をどのような数値に変換するかを表す文字
### なぜ&をつけるか
変数の場所を知らせるためのもの(15章でやる)

### 実数値の場合はどうなるのか
$lfを設定

### 複数キーボード待ちにするにはどうするのか
事前に変数を定義してメモリ確保。そこからアドレスを参照してキーボードの入力を受け付けるようにした
scanf("%d%d", &data1, &data2);
のように文字列リテラルを使う

### 今回のコードにおけるいいプログラムとは
1. 明確にカンマを使うことを指示
2. 正しく変数を使っている
3. 作る人にも使う人にもわかりやすい


### 入力ミスの恐怖とは

### 説明しておいてscanfが問題があるとは
入力ミスに対応していないところ
コンパイラの種類によっては大きな数字に対応できない

### 入力ミスの恐怖をなくすには
文字列に対してバリデーションを行うのが一般的

scanf
&
三角形の面積

入力ミスにより期待した値が入らない場合に正常な答えが出力されないため。

### 条件分岐

### c言語による条件判定とは
0はfalse, 0以外はtrue(負の値を含む)

```
if(条件) 処理
if(条件) {
  処理
}
```
メモリ上に変数を格納だけして何も代入しなかった時はtrueにならずにfalseになっている。明示的な0の代入が必要

### 初期化とは
変数の宣言と同時に数値を代入すること


false
true
ブロック構文

偶数か奇数

ifの条件式の定義より0以外であれば真の値を返すよって-1は0以外の数値より, okと表示される

### 場合分けとは
条件に一致しない時と一致する時を指す。elseのこと
```
if (条件) 真の場合; else 偽の場合;
```

### 3以上の場合分けは

else ifを使い条件を分けるか, インデントを下げた中にif文を増やすか

### 番号と対応させる処理
switch文を使う。if文は条件に合うものを一つずつ調べ洗濯するが, switchを使うとcaseにジャンプする
本質的にはgoto文
http://www.cc.kyoto-su.ac.jp/~yamada/ap/switch.html

### 条件が同じcaseは重複して書くのか
caseをまとめて書くことができる

### caseのデメリットは
条件がある一つに絞られるところ。複雑な判断をする場合はif文を使うしかない

else
if else構文
switch
オリンピックの開催された年

他のcaseの処理も行ってしまうので明示的に処理を抜けるという処理が必要


### ループ処理
### c言語における回数が決まっている処理とは
for文を使い回数の終了条件を設定し到達するまで実行する

```
int i;
for(i = 1; i < 繰り返したい回数; i++) {
  処理;
}
```
ループカウンタは事前に設定する必要がある

### ループ動作の仕組みとは
1. カウント変数の初期化は最初の一回のみ処理される
2. 条件式は書いてある条件が真の間は処理し続ける
3. 更新は繰り返し処理を行われた後に実行される

### 初期化, 条件設定,をしない場合はどうなるのか
無限ループに陥る。条件式を省略した場合は常にtrueになる
### どんな時に無限ループが使われるか
メモ帳のアプリなどに使われる。ユーザが自分で終了のボタンを押さない限りという条件にしてその間は絶えず実行するという流れ

### 無限ループの強制終了方法は
break文を途中に入れて終了させる

カウンター
無限ループ
9割引~1割引の間の値段を表示している
第一引数に初期化, 第二引数に条件式, 第三引数に処理をした後に行う処理を記述。定数回ループをする際はループカウンタの数を変更しながら条件式を満たして, 満たさなくなったら終了するという仕組み

### 回数を求めるループとは

### ねずみ算とは
ある決まった期間ごとに数値を次の期間に倍にした場合の値を求めるもの

### 入力チェック

### 後判定と先判定とは
### do~whileとはwhileと何が違うのか
```
do {
  繰り返し処理;
} while(条件);
```
while文は繰り返し処理の前に条件式を行う, do~whileは繰り返し処理後に条件を判定する

### do~whileのメリットは
条件式があとということは必ず一回は処理が実行されるということ。
処理実行後に条件式に合わなければ再度do~whileされるので下まで処理が行かない

### コンピュータでの円周率は
3.14159(今現在も同じかは不明)

先判定
後判定
毎年もらえる金額を10ずつ増やした時に何年で15000超えるか
入力値の値チェックをする時に向いている。処理 => チェック; の流れを作れる。while文だと
チェック => 処理になるので処理が重複したりする

### 自作関数作成
### プロトタイプ宣言とは
コンパイラに対して関数の情報を与えるもの。先頭で宣言しておくとmain関数より下に関数を作成しても呼び出すことができる
### stdio.hはどう関連しているの
printfなどの関数はstdio.hに書かれているものになる
### 定義した関数を呼び出せる条件とは
main関数より前に定義してmain関数の中で呼び出す。関数の数が増えたら整理するのが難しいというデメリットがある
### 戻り値を返す関数のて定義方法は
関数の前に返すデータ型を書く
### 戻り値が不要な場合は何を返すように設定するのか
void
プロトタイプ宣言
仮引数
実引数
戻り値
三角形の面積
分割統治のため, 再利用できる

### c言語の変数のスコープは
関数の中で宣言した変数は関数の実行が終了すると捨てられる。
別の関数が呼び出されると別のメモリに変数が割り当てられる
### ローカル変数とは
関数の中で寿命が終わる変数のこと
### main関数の中で定義すれば呼び出した関数でも有効なのか
宣言された関数の中で有効なので, 別の関数の中では無効。別の関数の中では定義されていないため
### 関数の独立性とは
関数自体が他の関数から呼び出されることを期待しているため, 仮に変数を使いまわすとしたら関数が呼び出せるたびに値が変わるので制御ができなくなる。使いたいところだけで使えなくなるということ

### c言語におけるglobal変数
関数外で宣言された変数。プログラム全体が終了するまで生き続け, 宣言されたソースファイル内の全ての関数から使用できる
### グローバル変数の初期化どんな働きをするのか
プログラムの開始時(メイン関数実行時に)自動的に0に設定される
### グローバル変数の値を途中で変えるとどうなるのか
全ての関数内で利用できるので途中で上書きされる
### 関数の中でグローバル変数とローカル変数が同じ名前を使われていたらどうなるのか
グローバル変数と同名のローカル変数がある場合はローカル変数が優先される
### グローバル変数の正確なスコープの範囲とは
1つのソースファイル内で共有される
### 静的なローカル変数の寿命とは
### 静的なローカル変数とは
型名の前にstaticをつける
static 型名 変数名;
関数内で宣言したにもかかわらず同じ関数を何回もよびだしても, 呼び出すごとに値が更新される.
### メリットは
関数が以前に使われた値をもう一度使いたい時に便利

ローカル変数
グローバル変数
静的なローカル変数

var => グローバル変数
count => ローカル変数
arc => 静的なローカル変数

関数野呼び出し毎に参照している変数の値が変わると思わぬ動作をする場合があるのため。


### c言語における配列
### 配列の宣言方法

型名 配列名[要素数];

### c言語の配列の初期値の代入方法は

型名 配列名[要素数] = {0スタート順でindex毎に値を代入, 指定外は0で埋まる}

### 要素数を省略した場合はどうなるのか
引数で受け取った数を上限とした数が設定される

### c言語で要素数の数だけループさせるときはどうするの
sizeof演算子を使いループさせる

sizeof(ary) / sizeof(ary[0])

### 配列を別の配列にコピーするには
memory.hをincludeしてmemcpy関数を使う
memcpy(コピー先, コピー元, 配列の要素数);

配列
配列のデータの平均を取っている
まとまったデータを扱えるので繰り返し処理を行う時に一度に全ての要素を扱える

### 文字の扱いについて

### c言語には文字列を扱う変数がないとはどういうことか
理由: 文字列は何文字になるかわからないのでメモリのじゅうぶんな確保ができない
しかし文字変数はある(char);キャラ; 一文字だけ記憶できる

### char型を使うときはダブルクォートは使えない
 要素数が変わってくるためシングルクォートを使う

### 文字コードとは
コンピュータで使える文字に1たい１でつかえる番号をつけて表現する方法.
asciiコードは半角アルファベットや記号が割り当てられている。
世界中の言語ようにunicordが一般的。
### char型に文字を入れるということは実際は何が起きているのか
書く文字は指定された文字コードおいて整数のmappingのルールが変わってくる。
Aは整数値の65が割り当てられている。char型の変数に割り当てられているのは実際は数字になりコンパイルする時に数字に関連づく値が取り出されるようになっている。
### char型に数字を足すとどうなるか
その指定番号にプラスされてマッピングされた値が出力される
### 数字の文字列を扱う時に引き算で本来の数値を知ることができるとはどういうことか
与えらえた数値からchar型の'0'を引くと'0'から対応する文字の距離を知ることができる。
### 文字を配列として扱うとは
char型のaryを作れば文字列になるということかも.
### 配列で文字列を管理することはわかるがどのようにして何文字使うかを知るのか
c言語では文字列の最後にEOSをつけると最後の文字だと判断してくれる
end of stringの略。"\0"

### 文字列を表すリテラルは
""で囲む

### 配列に文字列をセットするのが面倒だけどどうしたらいいか
文字列リテラルを使う
char str[] = "aaaa";
要素数は文字数プラス1確保される。初期化の時しか使えない

### 文字列の処理をする関数
### 文字列を数値に変換するにはよ
<stdlib.h>をincludeして`atoi`関数を使う
### 数字じゃない文字が含まれている場合はどうなるのか
0として扱われる
### 実数に変換したい場合は
`atof`関数が使われる
### 文字列の代入
char str[10];
strcpy(str, "文字列リテラル");
のようにしないと文字列の代入ができない。
str = "aaaaa";
はchar[10]に対して代入しようとしているのでコンパイルエラーになる
これを使わない場合はindexを指定して代入しないといけない

### 文字列の連結方法は
並べるだけで連結される
一度配列に代入したものに関してはstrcatを使って配列同士を結合する必要あり

### 究極の文字列合成関数とは
### sprintf関数はどんな振る舞いをするのか
結果を配列の中に記憶してくれる

### 文字数を知るためにはどうするか
文字列の一番最後がEOS == '\n'なので
```
int i;
for(i=0;str[i]!='\0';i++);
```
とするとeosに到達したらループが終了するので回数がわかる

### 文字列の要素数を知るプロトタイプ関数はないのか
strlenが用意されている

### 文字列の比較方法
str1 == str2というように比較をした場合文字列の内容の同一性を確かめているのではなく, 同じメモリを使っている配列かどうかを調べている

### 文字列の初期化で変数を用意した場合の挙動はどうなるのか
```
char str1[256], str2[] = "DRAGONQUEST";
str1 => 何もなし
str2 => "DRAGONQUEST"
```
### 文字列の比較にプラス1するのはなぜ
EOSが含まれているため

### 文字列の比較のプロトタイプ関数は
strcmp(a, b)どうやら同じだったら0がかえるみたい

文字コード
EOS
大文字のA~Zが出力される

文字列は長さが様々なので, 柔軟に対応するため。

### メモリの仕組みとは
### そもそもメモリとは
コンピュータのデータが記憶される箇所。
メモリには多くの電子部品が組み込まれてれいて一つ一つに状態がある。オンかオフの状態を持っている
メモリが64MBだと5億個以上の保存箇所が並んでいる
コンピュータは荷物を一つ一つそれぞれに保存している.
2進数で記憶している。
### cpuのビット数とは
現在は64ビットが主流。メモリとビットは関係がある。一つ一つの箇所に一つだけの2進数が入っているわけではない。
までの2進数が一つの部屋に入る。
一つのロッカーには1つの二進数が入る, 64ビットのコンピュータだと64*0~64*1までの値を2進数を使って表せる
### プログラムがどうやってメモリを取り扱っているか
8ビットは1バイトと表され
```
0000~1111
```
これが一つのグループ。これが64個連なったものが扱える数値の範囲。
量子コンピュータができたら仕組みが変わる

一つが0と１しか扱えないそれが8個連なるので 2 * 2 * 2 * 2 * 2 * 2 * 2* 2 == 2**8== 256

### 変数とメモリの関係は
### 変数はメモリ上に存在するとは
メモリは1バイト毎に番号が付与されている。プログラムで宣言された変数もメモリに番号付きで記憶されている。
わかりにくいため名前をつけて保存されている。実行ファイルにコンパイルされると変数名は番号になる。
### ポインタとは
### 変数のメモリ上の番号は確認できるのか
printfで%pを使って変数に'&'をつければ確認できる
### 変数につけられた番号をなんというか
アドレス。変数につけられたメモリ上の番号
### 自分の環境で調べたらどうなっていたの
0x7fff53a36508
0x7fff53a36504
int型で4番ずつづれている。int型のサイズは4バイト
1バイト = 8ビット(こっちの方が小さい単位)
4バイト = 32ビット
単純に考えると4294967296まで扱えるが+-の範囲になるので
半分の2147483648。
2147483647~-2147483648
int型の桁は2億1千ぐらいまで扱える。
### 配列の番号
配列のアドレスと配列の最初の要素のアドレスは同じ
よって配列名のアドレス+要素番号のメモリを参照するという意味になる

### &付き変数の正体とは
&は変数のアドレスを求める演算子。どんな変数でも&を使うとアドレスを求めることができる。
### 全ては値渡しとは
関数に単なる数値として情報を渡す方法。いくら変数で渡したとしても変数がメモリと結びついてそこからloadされて
渡される。
変数を実引数に指定しても渡されるのは中身の数値が渡される。
数値のコピーのようなものなので実際に変数の値が変更されることはない
### 参照渡しとは
&演算子を使ってアドレスを求め直接アドレスの番号を渡すことでアドレスに割り当てられている数値を変更することができる。
### なぜscanfで&をつけるのか
始めに宣言した変数のアドレスを渡すことでscanfでの入力値をアドレスに参照させることができる。
### なぜ文字列の入力にはアドレスを渡さなくていいのか
文字列はchar str[]。さらに先頭の要素がアドレスを指しているので実際はアドレスを渡していることになる
### アドレスを記憶する変数とは
### ポインタとは
アドレスを記憶することのできる変数が必要。
1. ポインタ型: データ型の一種
2. ポインタ値: ポインタで扱える数値, アドレスのこと
3. ポインタ変数: ポインタ型で宣言されたポインタ値を記憶できる変数。
### ポインタ型の詳細は
ポインタ型は他の型から作り出される派生型。
他の型とポインタ型を合体させたものがポインタ型という。キャストとかもポインタ型を変えてるだけのような気がしてきた。
アドレスを記憶する変数の型。他のポインタと合体させないとアドレスに記憶された数値を取り出すことはできない。
データ型のすべてのものはサイズが違う.int型だと4バイト=32ビット。変数を保存できるロッカーの数は億単位。
4/n億の値をデータを取り出すときは扱うことになる。

### ポインタ値の詳細は
変数のアドレスの値。&変数名で見てきたもの。
たんなる符号なしの整数値。数値だったらintを使えばいいかと思うが同じものでできていて役割が違えば別名をつけた方が扱いやすくなる

### ポインタ変数の詳細は

ポインタ型で宣言された変数。記憶しているアドレスのメモリをread/writeがができる
ポインタ変数の役割はそれが指し示しているアドレス番号のメモリの値を計算すること。

### ポインタが兼ね備えている変身機能とは
ポインタ変数モードと通常変数モードがある。
ポインタ変数はアドレスへの代入と足し算引き算のみ。
通常変数モードは通常の変数と同様に様々な演算子が使える。
何が使えるまでは言及していない

### ポインタ変数の宣言方法は
"*"はポインタ型を意味する記号。変数の前に記号をつける。型の後につけると意味合いが変わる。
### アドレスの代入方法は
メモリの範囲内の番号であればよい。
メモリ4GBだと0~42億までいける
仮想メモリによって適当にアドレスを設定できないようになっている。

### 上記のモードの切り替え方法は
デフォルトはポインタ変数モードになっている。参照モードかな。
ポイント変数モードの時に該当のアドレスを代入して, 通常変数モードに切り替えてメモリの操作をする。

### 仮想メモリとは
osがメモリを管理して適切にそれぞれのアプリケーションにメモリを振り分けること。
### 正常に管理されたアドレス番号を手に入れる方法とは
もう一つ別のアドレスを作成しそれをポインタのアドレスとして使えばosが管理しているアドレスを使うことになる。
### &変数が返す型て何
```
int *p;
int i;
p = &i;
```
これはポインタ型を返している。
pはintへのポイント型になっている
intのポインタを使うことを宣言。iでメモリ確保。iのアドレスをポインタpに設置。メモリにあるということは配置されている間はwrite/readができる

### ヌルポインタとは
NULLという記号をポインタ変数に代入しておけばアドレスが代入されていない, 使えない状態を意味することができる。
### ポイント型を宣言した直後はどんな値が入っているのか
デタラメな値が入っていて使用可能かどうかもわからない状態。

### ヌルポインタの値はどうなっているの
NULLが0だとは言えないが内部的にはNULLは0になっていることが多い
### ショートカットとは
### ポインタは一体何に役に立つのか
### 文脈上でのショートカットとは
どこか別の場所にあるファイルを指し示すファイル。
ショートカットは指し示すことしか書いていないので実際のファイルはそこにはない。どこにでも作れるし, 何個作っても問題ない
ポインタ変数に実際に存在する変数のアドレスを記憶しておけばポインタ変数が使える場所であれば元の変数g扱えない場所でも使える。よって値の書き換えも可能。

### c言語のポインタの特徴は
完全に手動なのでプログラマ自体が完全に理解して使う必要がある。上級者ならあらゆる構造をポインタだけで作成する。
別ファイルで関数によりはじき出された値をポインタに入れると共通で使えたりするから便利

### 引数による情報の受け渡し

### ポインタ型の引数とは
引数の型がただポインタなだけ。ポインタ型の引数を宣言するとアドレスを渡せる。すなわち値を変更することができる。
結果として呼び出された関数から呼び出し元の変数の中身を変更することができる。
### 配列型の引数とは
引数に配列を指定するだけ。しかし受け取る予定と異なるsizeを渡すと予期せぬ値になる。
またc言語は値渡しのはずが関数の中で値を変更すると元の値が変わってしまっている。
### 配列型引数の奇妙な性質とは
配列自体は値渡しされていない。
配列を引数で渡すときは配列ではなく配列の先頭のアドレスを渡している。
呼び出された関数での配列は呼び出した配列のアドレスを指しているので関数の途中で値を変更すると変更される。
```
int get_averate(int data[10]);
int get_averate(int data[]);
int get_averate(int *data);
```
全て同じ意味。2番目がよく使われる。

### 配列のポインタの関係とは
### なぜ配列とポインタを勘違いしてしまうのか
配列の設計が関連する。c言語では配列を実現するのにポインタを使っている
### ポインタ専用の書き方とは
*(ポインタ変数 + 要素番号)
### ポインタ演算とは
### アドレスのことは忘れていいとは
ポインタ変数がアドレスを記憶するとしてもそれは仕組みであり, 決定事項。
ポインタはショートカットという考えが大事。

ポインタ
ポインタ変数
ポインタのショートカットを関数に渡しているため。外にある関数の中で使われるポインタと&valueで渡したpointは同じになっているので結果的にvalueが更新されている

### 異なる型の変数のまとめ方
構造体を作るということになる
### 配列の中に同じ要素があってそれをまとめることはできたが別の方の様子はまとめられないのか
### c言語における構造化
`struct`を宣言しオブジェクト形式にする
### 構造体タグ名とは
作成した構造体自体の名前。しかし厳密には型名ではない

### 構造体はどこに定義するのか
すべての関数より前にする。全ての関数から構造体を使えるようにするため。
### 構造体で定義したものと今までの変数で宣言したものは何か違うのか
同じです
### 構造体タグを新しいタグとして設定するには
`typedef struct 新しい名前`
として宣言する
### 構造体の引数のルールは
構造体にすると一つの変数として複数の値を扱えるようになるため
### 構造体でのポインタの使い方は
&でもとまるのは構造体のはじめのアドレス。要素の取得には

`(*構造体ポインタ変数名).name`
`構造体ポインタ変数名->name`
などで取得可能

### 構造体のポインタ引数
### 関数がどうやってポインタ引数を受け取れるのか
関数の実装の時と同じで`*`を受け取るようにするだけ
### なぜ関数の実引数にポインタではなくアドレスを渡しているのか
ポインタを渡すとそのデータ自体を渡すことになるので構造体の中に大きなデータが入っている場合はそのまま渡すことになって大きな時間がかかる場合がある。しかしアドレスを渡せば変数の格納場所渡すだけなのでかかる時間も短くなるということ
一般的にはポインタ変数を渡す場合が多い
### まとめ
関数でもポインタを渡せる。そのさいのショートカットを渡しているいるという意識を持つ。
よって参照渡しになっているので値の変更も可能。

構造体


### c言語におけるテキストファイルの操作について
